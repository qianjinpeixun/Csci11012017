<HTML>

<HEAD>
<TITLE> Lecture 16 Notes, CSCI 2132 </TITLE>
</HEAD>

<BODY>
<h1>Lectures 16, CSCI 2132</h1>
<h3>The sizeof Operator</h3>
<p>The sizes of many C types are implementation-defined. Thus the sizeof operator is provided so that we can determine how many bytes are required to store a value of a particular type. The following is the syntax of using sizeof:</p>
<pre>sizeof(type)</pre>
<p>For example, we can use sizeof(char) to get the number of bytes required to store a char variable, which is 1. The value of the expression sizeof(int) could be 2, 4, 8 or other values, as the size of int is implementation-defined.</p>
<h2>Arrays</h2>
<h3>Types</h3>
<p>The basic types that we have learned so far are scalar types. A scalar type is a data type composed of a single element. In C, there are also aggregate types. An aggregate type is composed of multiple elements. The C arrays and structures are aggregate types.</p>
<h3>One-Dimensional Arrays</h3>
<p>Conceptually, a one-dimensional array is a fixed sequence of elements of the same type. Physically, a one-dimensional array is stored as consecutive bytes in memory. </p>
<p>To declare a one-dimensional array, we follow this syntax:</p>
<pre>type name[size]</pre>
<p>Here size must be an integer constant expression. For example, the following line of code declares an array named a that can store 40 int values:</p>
<pre>int a[40];</pre>
<p>When we declare an array, memory storage for the array is allocated. This is different from Java: In Java, we declare an array first without specifying its length, and we then use the new operator to allocate memory for it.</p>
<p>C arrays defined this way in a function are stored in stack memory. Recall that the memory space of a process is composed of four parts: code, data, stack and heap. As Java arrays are dynamically allocated, they are stored in heap memory.</p>
<p>Stack allocation is fast. In the stack memory, variable sizes are fixed and programmers cannot free any memory until the function returns. For heap memory, more management is required. That's why C arrays defined as above are allocated in the stack memory. We will learn more about how stack / heap memory is managed when we learn functions / pointers.</p>
<p>Note that in Java 6 (proposed in 2006, which was 11 years after Java was introduced), they introduced &quot;escape analysis&quot; to speed up Java arrays. What this essentially does is to require the Java compiler to analyze whether a Java array can be allocated in stack or not. If it can, then it will be allocated in the stack. This improves the efficiency of Java programs significantly.</p>
<p>C programmers often define an array length as a macro. This way it is easy to modify the program. For example, we can define N to be 40:</p>
<pre>#define N 40</pre>
<p>After this, we can use N to declare arrays:</p>
<pre>int a[N];</pre>
<p>Array subscripting allows us to access each element of the array. For the array a defined above, its elements are a[0], a[1], ..., a[N-1]. When we use a subscript that is out of the range of indexes of an array (for example, if we attempt to access a[40] in this array), the behavior of the program will be undefined. This is because C does not require subscript bounds to be checked, as efficiency is important in C. In Java, this is checked, so a run-time error would be generated when we index an array out of range. This makes it easier to debug a Java program, but this sacrifices efficiency as checking this requires additional time.</p>
<p>An array can be given an initial value at the time it is declared, using an array initializer. For example, the following line of code declares an array of length 10 and stores 1, 2, 3, ..., 10 in it:</p>
<pre>int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</pre>
<p>The array length could be dropped if the initializer initializes all its elements. Hence the following line of code performs the same task:</p>
<pre>int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</pre>
<p>The initializer can have fewer elements than the array length. The values in the initializer will be stored in the entries 0, 1, 2,... of the array, and the remaining array elements will be assigned 0. For example, the following line of code declares an array that stores 1, 2, 3, 0, 0, ..., 0:</p>
<pre>int a[10] = {1, 2, 3};</pre>
<p>We can take advantage of this to declare and initialize an array of all 0s:</p>
<pre>int a[10] = {0};</pre>
<p>When an initializer is not present, the array elements are not given initial values. This is different in Java, in which array elements are assigned default values once an array is allocated.</p>
<p>We then used what we learned to implement binary search. The source code can be found at:</p>
<pre>/users/faculty/prof2132/public/binary.c</pre>
<p>We filled in the blanks together in class.</p>
<h3>&nbsp;</h3>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
</BODY>

</HTML>
